//go:build generator

package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"text/template"
)

const stackTemplate = `
// Code generated by stack-generator. DO NOT EDIT.

package {{ .Package }}
{{ if .Imports }}
import (
{{ range .Imports }}
	"{{ . }}"
{{ end }}
)
{{ end }}

// Stack{{ .TypeName }} represents {{ .Type }} stack
type Stack{{ .TypeName }} struct {
	values []{{ .Type }}
}

// Push pushes {{ .Type }} values on top of stack
func (s *Stack{{ .TypeName }}) Push(v ...{{ .Type }}) {
	s.values = append(s.values, v...)
}

// Pop pops {{ .Type }} from top of stack
func (s *Stack{{ .TypeName }}) Pop() {{ .Type }} {
	i := len(s.values) - 1
	v := s.values[i]
	s.values = s.values[:i]
	return v
}

// Top gets {{ .Type }} from top of stack
func (s *Stack{{ .TypeName }}) Top() {{ .Type }} {
	return s.values[len(s.values)-1]
}

// Size returns size of stack
func (s *Stack{{ .TypeName }}) Size() int {
	return len(s.values)
}

// Empty returns true if stack is empty
func (s *Stack{{ .TypeName }}) Empty() bool {
	return len(s.values) == 0
}

// Values returns slice of {{ .Type }} stored in stack
func (s *Stack{{ .TypeName }}) Values() []{{ .Type }} {
	return s.values
}
`

type StackDefinition struct {
	Package  string
	Imports  []string
	TypeName string
	Type     string
}

func main() {
	filenameFlag := flag.String("o", "", "Output file")
	packageFlag := flag.String("p", "", "Package name")
	importsFlag := flag.String("i", "", "Imports (comma separated)")
	typeNameFlag := flag.String("n", "", "Type name suffix")
	typeFlag := flag.String("t", "", "Go type name")

	flag.Parse()

	if *filenameFlag == "" {
		exitWithError("Output file can't be empty")
	}
	if *packageFlag == "" {
		exitWithError("Package name can't be empty")
	}
	if *typeNameFlag == "" {
		exitWithError("Type name suffix can't be empty")
	}
	if *typeFlag == "" {
		exitWithError("Go type name can't be empty")
	}

	var imports []string
	if *importsFlag != "" {
		strings.Split(*importsFlag, ",")
	}

	st := StackDefinition{
		Package:  *packageFlag,
		Imports:  imports,
		TypeName: *typeNameFlag,
		Type:     *typeFlag,
	}

	stackTemp, err := template.New("stack-template").Parse(stackTemplate)
	if err != nil {
		exitWithError(err.Error())
	}

	file, err := os.OpenFile(*filenameFlag, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, os.ModePerm)
	if err != nil {
		exitWithError(err.Error())
	}
	defer func() {
		_ = file.Close()
	}()

	if err = stackTemp.Execute(file, st); err != nil {
		exitWithError(err.Error())
	}

	// Will be run in goimports
	// if err = exec.Command("gofmt", "-w", *filenameFlag).Run(); err != nil {
	// 	 exitWithError(err.Error())
	// }

	if err = exec.Command("goimports", "-w", *filenameFlag).Run(); err != nil {
		exitWithError(err.Error())
	}
}

func exitWithError(err string) {
	fmt.Println("ERROR:", err)
	flag.Usage()
	os.Exit(1)
}
